# event-machine-skeleton
Dockerized skeleton for prooph software [Event Machine](https://github.com/proophsoftware/event-machine)

## Installation
Please make sure you have installed [Docker](https://docs.docker.com/engine/installation/ "Install Docker") and [Docker Compose](https://docs.docker.com/compose/install/ "Install Docker Compose").

```bash
$ docker run --rm -it -v $(pwd):/app prooph/composer:7.1 create-project proophsoftware/event-machine-skeleton
$ cd event-machine-skeleton
$ sudo chown $(id -u -n):$(id -g -n) . -R
$ docker-compose up -d
$ docker-compose run php php scripts/create_event_stream.php
```
## Quick Start

Head over to `http://localhost:8080` to check if the containers are up and running.
You should see a "It works" message.

Let's register a user in our new application. It is a small example that already illustrates the power of Event Machine.

1. Create a folder named "Model" in `src`
2. Add a class `UserDescription` and copy and paste the content from [that gist](https://gist.github.com/codeliner/20c3944195d0c60ceb2a4bbe6d3d2638#file-userdescription-php) into it.
3. Register `UserDescription` in Event Machine by adding it to `config/autoload/global.php` (see [gist](https://gist.github.com/codeliner/20c3944195d0c60ceb2a4bbe6d3d2638#file-global-php) )
4. Open [Postman](https://www.getpostman.com/) and import the [example collection](https://gist.github.com/codeliner/20c3944195d0c60ceb2a4bbe6d3d2638#file-eventmachine_example-postman_collection-json)
5. Send the "RegisterUser" request
6. Event Machine should return a 202 Accepted response with an empty body
7. Have a look at the postgres db, see `docker-compose.yml` of the skeleton for login credentials
8. The table starting with _ followed by a sha1 hash is your "event_stream" table. You should see a new `UserWasRegistered` event in it.
9. Test also the "ChangeUsername" request
10. Exercise: Implement the "ChangeEmail" use case

## GraphQL 
The skeleton also exposes a GraphQL endpoint. You can send the same commands from above using GraphQL and also test the `User` query.
The easiest way is to install one of the available GraphQL clients for Google Chrome:

- [ChromeiQL](https://chrome.google.com/webstore/detail/chromeiql/fkkiamalmpiidkljmicmjfbieiclmeij)
- [GraphiQL Feen](https://chrome.google.com/webstore/detail/graphiql-feen/mcbfdonlkfpbfdpimkjilhdneikhfklp)

Point your GraphQL client to `http://localhost:8080/api/graphql`. It should inspect the schema generated by event machine and suggest you
two *mutations* `RegisterUser` and `ChangeUsername` as well as a *query* `User(userId: String!): User!`.

Registering a user using GraphQL looks like this:

```graphql
mutation {
  RegisterUser(
    userId:"488312e8-c7d0-46a5-b5ed-f97cc925f191",
    username:"John",
    email:"john.doe@acm.local"
  )
}

# Response:
#
# {
#   "data": {
#     "RegisterUser": true
#   }
# }
```

## Batteries Included

You know the headline from Docker, right?
The Event Machine skeleton follows the same principle. It ships with a default set up so that you can start without messing around with configuration and such.
The default set up is likely not what you want to use in production. The skeleton can be and **should be** adapted.

Focus of the skeleton is to provide *an easy to use development environment*, hence it uses default settings of Postgres, MongoDB and RabbitMQ containers.
**Make sure to secure the containers before you deploy them anywhere!** You should build and use your own docker containers in production anyway.
And if you cannot or don't want to use Docker then provide the needed infrastructure the way you prefer and just point event machine to it by adjusting configuration.

### Postgres Event Store

Event Machine skeleton uses prooph's [Postgres event store](https://github.com/prooph/pdo-event-store) by default. 
It is fully set up with transaction management and event publishing after transaction commit (done by Event Machine).
 
### MongoDB Projections

Event Machine ships with a neat feature called **aggregate projection**. To explain it we should take a look at the user aggregate description from
the linked gist.

```php
$eventMachine
//...
->apply(function (Message $userWasRegistered) {
    $userState = $userWasRegistered->payload();
    return $userState;
});

$eventMachine
//...
->apply(function(array $userState, Message $usernameWasChanged) {
    $userState['username'] = $usernameWasChanged->payload()['newUsername'];
    return $userState;
});
```
What you return as `state` from an aggregate `apply` method is persisted by the `aggregate_projection` as a document.
Each time `state` changes, the corresponding projection document is updated, too. This happens fully automatic and runs
in the background. You can register such aggregate projections and/or define your own. See event machine docs for details.

The skeleton use a single `PostgreSQL` database as event-store and as a *document store*. This is configurable so you can use
other `prooph/event-store` implementations or your own read model database(s).

### RabbitMQ messaging and web sockets

Event machine ships with a preconfigured rabbitmq docker container using the dev image `prooph/rabbitmq`.
A [Humus\AmqpMessageProducer](https://github.com/prooph/humus-amqp-producer) is ready to use (for development) to forward messages
via websocket to a JavaScript consumer. An example consumer is shown in `public/ws.html`.

To test the rabbitmq + websocket set up you can open `http://localhost:8080/ws.html` in a browser and use the browser debug console
to check if a connection to the websocket endpoint under `wss://localhost:15691/ws` can be established.
If you see the stomp client pinging the websocket endpoint everything is fine and you can send some messages from event machine to the client.

A use case is prepared. Send the `Ã€pp.ChangeUsername` request again. If you get a 202 response in postman check the browser console
and you should find a `UsernameWasChanged` event. How cool is that?

You could now combine that with your favorite JavaScript framework and directly react on event machine events in the client.

*Note: Events are not forwarded to the client automatically. In the [UserDescription](https://gist.github.com/codeliner/20c3944195d0c60ceb2a4bbe6d3d2638#file-userdescription-php-L79) you can find an example how forwarding is set up per event.*
